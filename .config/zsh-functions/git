#---GIT AUTOMOATION-------------------------------------------------------
# vim: nospell syntax=zsh


function _z_git_config()
{
	REPOS_DIR="$HOME/src"
}

g()
{
	_z_git_config

	local REPO="$1"
	local NAME="${REPO#*:}"
	local FOLDER="${REPOS_DIR}/${NAME%.git}"

	if [ -e "$FOLDER" ]
	then
		cd "$FOLDER"
		return 0
	fi

	if [ "$REPO" = "${REPO#*:}" ]
	then
		if [ "${REPO%%/*}" = "gocomparegroup" ] || [ "${REPO%%/*}" = "javajawa" ]
		then
			REPO="git@github.com:${REPO%.git}.git"
		else
			REPO="git@gitlab.futurenet.com:${REPO%.git}.git"
		fi
	fi

	command git clone "$REPO" "$FOLDER" && cd "$FOLDER"
}

mr()
{
	local BRANCH=$(command git rev-parse --abbrev-ref HEAD)

	if [ $? -ne 0 ]
	then
		printf >&2 "Unable to determine a current branch. Is this really a git repo?\n"
		return $?
	fi

	local REMOTE=$(command git config --get "branch.${BRANCH}.remote")
	REMOTE=${REMOTE:-origin}

	local UPSTREAM=$(command git config --get "branch.${BRANCH}.merge")
	UPSTREAM=${UPSTREAM#refs/heads/}

	local DEFAULT_BRANCH=$(command git rev-parse --abbrev-ref "refs/remotes/$REMOTE/HEAD")
	DEFAULT_BRANCH=${DEFAULT_BRANCH#$REMOTE/}
	DEFUALT_BRANCH=${DEFAULT_BRANCH:-master}

	if [ "$BRANCH" = "$DEFAULT_BRANCH" ] || [ "$UPSTREAM" = "$DEFAULT_BRANCH" ]
	then
		printf "Enter new branch name: "
		read -r BRANCH

		git checkout -b "$BRANCH"
		unset UPSTREAM
	fi

	if [ -n "$UPSTREAM" ]
	then
		command git push "$REMOTE" "${BRANCH}" -o merge_request.create -o "merge_request.target=${DEFAULT_BRANCH}" --no-verify
	else
		command git push "$REMOTE" "${BRANCH}:${BRANCH}" -u -o merge_request.create -o "merge_request.target=${DEFAULT_BRANCH}" --no-verify
	fi
}

git_update()
{
	local BRANCH=$(command git branch --show-current)

	if [ $? -ne 0 ]
	then
		X=$?
		printf >&2 "Unable to determine a currnt branch. Is this really a git repo?\n"
		return $X
	fi

	local PORCELAIN_STATUS="$(command git status --porcelain)"
	local STASH=0

	if [ -n "$PORCELAIN_STATUS" ]
	then
		if [ -n "$(printf "%s" "$PORCELAIN_STATUS" | grep -v "^??")" ]
		then
			printf >&2 "%s\n" "$PORCELAIN_STATUS"
			printf >&2 "Local changes detected. Enter [stash] to stash (otherwise will abort) > "
			local CHOICE
			read CHOICE

			if [ "$CHOICE" != "stash" ]
			then
				return 1
			fi

			if ! git stash push --include-untracked
			then
				printf >&2 "Error stashing changes"
				return 1
			fi

			STASH=1
		else
			printf >&2 "%s\n" "$PORCELAIN_STATUS"
			printf >&2 "Untracked changes detected, process? [Yn] > "
			local CHOICE
			read CHOICE

			if [ "$CHOICE" = "n" ]
			then
				return 1
			fi
		fi
	fi

	local REMOTE
	local DEFAULT_BRANCH

	# See if the user has set an explicit default remote.
	REMOTE=$(command git config --get checkout.defaultRemote)

	if [ -z "$REMOTE" ]
	then
		REMOTE=$(command git config --get "branch.${BRANCH}.remote")
		REMOTE=${REMOTE:-origin}

		printf >&2 "Warning: no default remote set. What should I use? [%s] > " "$REMOTE"
		local SET_REMOTE
		read SET_REMOTE

		REMOTE=${SET_REMOTE:-$REMOTE}

		command git config checkout.defaultRemote "$REMOTE"
		unset SET_REMOTE
	fi

	# Look for a HEAD branch to indicate default branch
	DEFAULT_BRANCH=$(git rev-parse --verify --symbolic-full-name --abbrev-ref origin/HEAD)

	if [ -n "$DEFAULT_BRANCH" ] && [ "$DEFAULT_BRANCH" != "${DEFAULT_BRANCH#${REMOTE}/}" ]
	then
		DEFAULT_BRANCH=${DEFAULT_BRANCH#${REMOTE}/}
	else
		printf >&2 "Warning: default remote %s has no HEAD branch (or it is weird).\n"

		for DEFAULT_BRANCH in mainline develop main master
		do
			if [ -n $(git rev-parse --verify "$BRANCH" 2>/dev/null) ]
			then
				break
			fi
		done

		printf >&2 "What value should I use for HEAD? [%s] > " "$DEFUALT_BRANCH"
		local SET_BRANCH
		read SET_BRANCH

		DEFAULT_BRANCH=${SET_BRANCH:-$DEFAULT_BRANCH}
		command git remote set-head "$ORIGIN" "$DEFAULT_BRANCH"
		unset SET_BRANCH
	fi

	command git fetch --prune --all && \
	git checkout "$DEFAULT_BRANCH" && \
	command git merge "$REMOTE/HEAD" --ff-only || return 1

	local SELF=$(command git rev-parse --symbolic-full-name HEAD)

	command git branch --format '%(refname)' --merged=HEAD | while read REF
	do
		if [ "$REF" != "$SELF" ]
		then
			command git branch -d "${REF#refs/heads/}"
		fi
	done

	if [ "$STASH" = 1 ]
	then
		git stash pop
	fi
}

git_redo()
{
	git add -u && git commit --amend --no-edit && git push --force-with-lease
}

get_gitlab_repos()
{
	_z_git_config

	test -r ~/.config/gitlab-token && source ~/.config/gitlab-token

	if [ -z "$GITLAB_TOKEN" ]
	then
		printf >&2 "GITLAB_TOKEN not set\n"
		return 1
	fi

	typeset -aU ALL_REPOS=()
	PAGE=0

	while true
	do
		PAGE=$(( $PAGE + 1 ))

		REPOS=("${(@f)$(curl -sS "https://gitlab.futurenet.com/api/v4/projects?archived=0&membership=1&per_page=100&page=${PAGE}&private_token=$GITLAB_TOKEN" | jq --raw-output '.[].path_with_namespace')}")
		ALL_REPOS+=($REPOS)

		if [ "${#REPOS}" -lt 100 ]
		then
			break
		fi
	done

	printf >"$HOME/.zshcache/gitlab-repos" "%s" "$ALL_REPOS"
	printf >&2 "Cached ${#ALL_REPOS} repos\n"
}

_g()
{
	_arguments '1: :->repo'
	_z_git_config

	if [ "$state" = "repo" ]
	then
		typeset -aU ALL_REPOS

		LOCAL_REPOS=("${(@f)$(find "$REPOS_DIR" -maxdepth 3 -type d -name .git -print | sed -e "s@$REPOS_DIR/@@" -e 's@/.git@@')}")
		REMOTE_REPOS=($(cat "$HOME/.zshcache/gitlab-repos"))

		ALL_REPOS+=($LOCAL_REPOS)
		ALL_REPOS+=($REMOTE_REPOS)

		compadd "$@" $ALL_REPOS
	fi
}

compdef _g g


git_prompt()
{
	readonly local CURR_DIR="$(pwd)/"

	if [ -n "$CURRENT_GIT_DIR" ]
	then
		test "${CURR_DIR#$CURRENT_GIT_DIR}" != "${CURR_DIR}" && return 0

		printf >&2 "[Leaving git repo %s]\n" "$CURRENT_GIT_DIR"

		unset CURRENT_GIT_DIR
		unset "PROMPT_INFO[git]"
		set_prompt
	fi

	DIR=$(git rev-parse --show-toplevel 2>/dev/null)

	if [ -n "$DIR" ] && [ "$DIR" != "$HOME" ]
	then
		printf >&2 "[Entering git repo %s]\n" "$DIR"

		CURRENT_GIT_DIR=$DIR
		PROMPT_INFO[git]=$(command git rev-parse --abbrev-ref HEAD)
		set_prompt
	fi
}

git()
{
	command git "$@"
	if [ -n "$CURRENT_GIT_DIR" ]
	then
		PROMPT_INFO[git]=$(command git rev-parse --abbrev-ref HEAD)
		set_prompt
	fi
}

add-zsh-hook chpwd git_prompt
CURRENT_GIT_DIR=
git_prompt
